/**
 * Copyright (c) Facebook, Inc. and its affiliates. 
 */

const Multipeer = require('Multipeer')
const Participants = require('Participants')
const SparkAutomergeWrapper = require('./spark_automerge_wrapper')
const Time = require('Time')
const uuidv5 = require('uuid/v5');

/**
 * Sends the update message generated by automerge through the given channel
 */
function sendUpdateMessages(state, syncStates, myParticipantId, channel) {
  const syncMessages = SparkAutomergeWrapper.generateSyncMessages(state, syncStates, myParticipantId)
  syncMessages.forEach(msg => channel.sendMessage(msg))
}

function getUuid(participantId) {
  const applicationUuid = 'f1776fff-a987-5457-9327-ead2a9e3a4db'
  const uuid =  uuidv5(participantId, applicationUuid)
  // This is to make it compatible with automerge's actorId
  return uuid.replace(/-/g, '')
}

export async function createGlobalSignal(signal, startValue, signalName, guaranteeStateKey, updateState) {
  const channel = Multipeer.getBinaryMessageChannel(signalName)
  const myUuid = getUuid((await Participants.self).id)
  let state = SparkAutomergeWrapper.init()

  const allPeers = await Participants.getAllOtherParticipants()
  const syncStates = {}

  for (const peer of allPeers) {
    const peerUuid = getUuid(peer.id)
    SparkAutomergeWrapper.initPeerSyncState(syncStates, peerUuid)
    peer.isActiveInSameEffect.monitor().subscribe(function (event) {
      const isLatestActive = event.newVal
      if (!isLatestActive) {
        SparkAutomergeWrapper.initPeerSyncState(syncStates, peerUuid)
      }
    })
  }

  let delayTimer;
  let lastDelayTime = null;
  channel.onMessage.subscribe((msg) => {
    const [nextBackend, patch, ignoreMessage] = SparkAutomergeWrapper.processMessage(state, syncStates, myUuid, msg)
    if (ignoreMessage) {
      return
    }
    state = nextBackend

    if (patch) {
      const newValue = SparkAutomergeWrapper.get(state, signalName)
      if (signal.pinLastValue() !== newValue) {
        signal.setValueOnly(newValue)
      }
    }

    // Delay the message passing when the value is updated from the network, to
    // prevent each node from sending too many messages at any one time.
    // Otherwise, all ack and sync messages are duplicated and storm the network.
    if (delayTimer) {
      delayTimer.unsubscribe();
    }

    const currentTime = Date.now();
    if (lastDelayTime === null) {
      lastDelayTime = currentTime;
    }

    if (currentTime - lastDelayTime > 2000) {
      // Send update messages immediately if it has been delayed for more than 2 seconds
      sendUpdateMessages(state, syncStates, myUuid, channel);
      lastDelayTime = null;
    } else {
      // Schedule the update messages to be sent 100ms later.
      // This is to reduce the number of update messages responding to other peers' sync messages
      delayTimer = Time.setTimeout(() => {
        sendUpdateMessages(state, syncStates, myUuid, channel);
        lastDelayTime = null;
      }, 100);
    }
  })

  signal.updateState = function (event) {
    state = guaranteeStateKey(state, signalName, startValue)
    state = updateState(state, signalName, event)
    sendUpdateMessages(state, syncStates, myUuid, channel)
  };

  sendUpdateMessages(state, syncStates, myUuid, channel)

  signal.getName = () => signalName
}
